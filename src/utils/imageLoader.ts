import { WallpaperImage, CategoryConfig } from '../types';
import { WALLPAPER_CATEGORIES } from './constants';

// Import the generated image manifest (will be created by build script)
let imageManifest: Record<string, string[]> = {};

// Try to load the manifest, fallback to hardcoded list if not available
try {
  // This will be generated by the build script
  imageManifest = require('../data/imageManifest.json');
  console.log('Loaded image manifest:', imageManifest);
} catch (error) {
  console.warn('Failed to load image manifest, using fallback:', error);
  // Fallback to current known images
  imageManifest = {
    rajini: [
      '183160b768465b686cdb7aafa99cccc5.jpg',
      '2a54a5f5b7a844923311411a2d68da3c.jpg',
      '9215ed34ce4c841ef307d148339f6515.jpg',
      'b2fc0dfa57b17254d4ded63993b3917b.jpg',
      'bf424df0eca803526cee028a9ef419c8.jpg',
      'c192692294a5f6a269794a1f7cc738cf.jpg',
      'efc647edaadddc9b8d2084ec3a0d0436.jpg',
      'Thalapathy Movie Rajinikanth.jpeg'
    ],
    kamal: [
      '6a6408be15cd1e70a5df0f9848b6a5af (1).jpg',
      '6a6408be15cd1e70a5df0f9848b6a5af.jpg',
      '8b707f8aaae421c1138c4ffb5f7628bb.jpg'
    ],
    common_mass: [
      '2300fee19837861494641861116980ee.jpg',
      '2e534c614c562634f7f74034f9a503c9.jpg',
      '3d62aaf3d09f8b00c03685cc308b92fa.jpg',
      '4082b1e37ffdfcc9fa38159dadaccb17.jpg',
      '618084c21a00942335d5ca3dac51ed17.jpg',
      '7c3f344a162c03516a2d213d05bd14eb.jpg',
      '9c743a378ac5901ee040ecd272933634.jpg',
      '9f6c2a08e9c7432add440ce2f1f434a1.jpg',
      'c6d3c282ac356d2bf0b64ae221a06dcb.jpg',
      'download (1).png',
      'download.png'
    ],
    automobile: [
      '0719eeee4fe543a5cd59d74093fd1a60.jpg',
      '0c34d4a4678aaa278ca3bd3667b938ad.jpg',
      '10c59d3a4300d7088c1c55639a168d72.jpg',
      '18c0fd619f647cc105998012c9f4501f.jpg',
      '1f637ed40710da202bed91cf0ee7c842.jpg',
      '2161839ec94977ef06a68b69f988e182.jpg',
      '230af357c9506065da9ef612f3f9c2c8.jpg',
      '3daab7279174ca42705cdfcb006d89f5.jpg',
      '455e53819c86ae83ded135bf63471290.jpg',
      '6adbc9db1fb793c6514290bb9a7cbf0b.jpg',
      '6c24758749d20503e526e47eb4f35c56.jpg',
      '736d1fc83f95cfbe0e668a50f28279c7.jpg',
      '904bc157166d2a58b389d85eef963ef6.jpg',
      '99f17ccf47325726cd9d396138e0fb09.jpg',
      'c8084ab3a075a0a58406b893e6d80792.jpg',
      'd0b14a7bad86fa2a40436404b25a4dfe.jpg',
      'd68340f29151017b75c3cb8856577f48.jpg',
      'e15aa58261b0c253a1d82b332d453e38.jpg',
      'e79d844f37d4b8137277a2f5d04ab1d1.jpg',
      'ebbaba49e0acdf2ef594c5c8b5721a5c.jpg',
      'ebf148c7fea44ed9da4446d6bb9b5b23.jpg',
      'f1e0409b472b64fa0b79b3e131c708e2.jpg',
      'f41f77cdd2bb2accfcacb1663b14baf4.jpg'
    ],
    motivational: [
      '241c0b8f3e23e36b03f54cef3abfaf59.jpg',
      '2f4a623e29593aaf308c810360fd4f49.jpg',
      '3a198aec4dd0bff0ec7324c6fb6d402f.jpg',
      '42d9f55012b192fdd413f8ff30953cbc.jpg',
      '585b4f26a6b03cad75926197a2898e5b.jpg',
      '8053b96c0e62bb7253751f9b59674ced.jpg',
      '8504805b1ba2e15fd0717c1d6c2ac1fc.jpg',
      '90a2feda1b37fe424413d6dffee584ff.jpg',
      'a9018dd554e4db3ccfdbfa5ac2d77057.jpg',
      'b3a7dea905bfa34cd14e8b3a5d381817.jpg',
      'ccbf76c869ce67d930278852888dc997.jpg',
      'db7eab4fc2ada5526a1d99e3e0f3e1eb.jpg',
      'download.png',
      'e60ec0b722db2be60df0639d28b790e1.jpg',
      'e7f9b22cb6764147a9f65b3302831c0b.jpg',
      'f148553000afbafdcfaa83bec722b4f3.jpg',
      'f6843555658beba42b8c5808bd813079.jpg',
      'fa8b202e2a1f020abe41b823e4bf30cc.jpg'
    ],
    nature: [
      '13863e5a80feecfa438c88e460288d46.jpg',
      'f44afe81b880a53100049c031c8afd93.jpg'
    ],
    spiritual: [
      '25c5e21914cb7b07a01805aa72f91a59.jpg',
      'download (1).png',
      'download.png',
      'ec809e7b3d96a4c287d0a1117ecc17c0.jpg'
    ],
    random: [
      '0ab0b205f9985c50142e719c97e47b0d.jpg',
      '9681a53211c39a18f1c46132fb89c2e9.jpg'
    ],
    anime: [
      'characters/44a72ef96d0cb141b5a25519344ba4e0.jpg',
      'characters/8e901f7e4827cac9073ae2c3131d90fa.jpg',
      'places/11b9bc76763e9e07b3af0353c8c4edfb.jpg',
      'places/42e18fcd2b236e57c0b8517bea6bd979.jpg',
      'places/6176222d555e0023f9bcd1a50bab374c.jpg',
      'places/75c62e19a9bc9136f17968ab7b9d2ac6.jpg',
      'places/7632d32062dd523d9d7efedbc84f06f9.jpg',
      'places/a1b6382df31b01e04742d8a48183afba.jpg',
      'places/d59cd9027b79f5b5d3fb128257b8c890.jpg',
      'places/f29ac662ef580ee016aff1d92ac3e2f7.jpg'
    ],
    bikes: [],
    ai: [],
    tech: []
  };
}

/**
 * Utility functions for loading and managing wallpaper images
 */

/**
 * Get all available images for specified categories (USER SELECTED CATEGORIES)
 * This is where the filtering happens based on user's category selection
 */
export const getImagesForCategories = async (selectedCategories: string[]): Promise<WallpaperImage[]> => {
  // Handle edge case: no categories selected
  if (selectedCategories.length === 0) {
    console.log('No categories selected - returning empty array for black background');
    return [];
  }

  const allImages: WallpaperImage[] = [];
  const failedCategories: string[] = [];
  
  // Only process the categories that the user has selected
  for (const category of selectedCategories) {
    // Validate category name
    if (!isValidCategory(category)) {
      console.warn(`Invalid category name: ${category}`);
      failedCategories.push(category);
      continue;
    }

    try {
      const categoryImages = await getImagesForCategory(category);
      if (categoryImages.length > 0) {
        allImages.push(...categoryImages);
        console.log(`Successfully loaded ${categoryImages.length} images from category: ${category}`);
      } else {
        console.warn(`No images found for category: ${category}`);
        failedCategories.push(category);
      }
    } catch (error) {
      console.warn(`Failed to load images for category: ${category}`, error);
      failedCategories.push(category);
    }
  }
  
  // Log results for debugging
  const successfulCategories = selectedCategories.filter(cat => !failedCategories.includes(cat));
  console.log(`Category filtering results:`, {
    selectedCategories,
    successfulCategories,
    failedCategories,
    totalImages: allImages.length
  });
  
  return allImages;
};

/**
 * Get all images for a specific category from the manifest
 */
export const getImagesForCategory = async (category: string): Promise<WallpaperImage[]> => {
  const filenames = imageManifest[category] || [];
  console.log(`Getting images for category ${category}:`, filenames);
  
  const images = filenames.map(filename => ({
    src: `${process.env.PUBLIC_URL}/wallpapers/${category}/${filename}`,
    category,
    filename
  }));
  
  console.log(`Created ${images.length} image objects for category ${category}`);
  return images;
};

/**
 * Preload an image to ensure smooth transitions
 */
export const preloadImage = (src: string): Promise<void> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    
    // Set timeout to prevent hanging on slow/broken images
    const timeout = setTimeout(() => {
      reject(new Error(`Image load timeout: ${src}`));
    }, 10000); // 10 second timeout
    
    img.onload = () => {
      clearTimeout(timeout);
      resolve();
    };
    
    img.onerror = () => {
      clearTimeout(timeout);
      reject(new Error(`Failed to load image: ${src}`));
    };
    
    img.src = src;
  });
};

/**
 * Lazy load image with Intersection Observer API
 */
export const lazyLoadImage = (src: string, options: {
  rootMargin?: string;
  threshold?: number;
} = {}): Promise<HTMLImageElement> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    
    // Default options for lazy loading
    const { rootMargin = '50px', threshold = 0.1 } = options;
    
    // Set timeout for loading
    const timeout = setTimeout(() => {
      reject(new Error(`Lazy load timeout: ${src}`));
    }, 15000); // 15 second timeout for lazy loading
    
    img.onload = () => {
      clearTimeout(timeout);
      resolve(img);
    };
    
    img.onerror = () => {
      clearTimeout(timeout);
      reject(new Error(`Failed to lazy load image: ${src}`));
    };
    
    // Use Intersection Observer for lazy loading if supported
    if ('IntersectionObserver' in window) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            img.src = src;
            observer.unobserve(img);
          }
        });
      }, { rootMargin, threshold });
      
      // Create a placeholder element to observe
      const placeholder = document.createElement('div');
      placeholder.style.width = '1px';
      placeholder.style.height = '1px';
      placeholder.style.position = 'absolute';
      placeholder.style.top = '0';
      placeholder.style.left = '0';
      document.body.appendChild(placeholder);
      
      observer.observe(placeholder);
      
      // Clean up placeholder after loading
      img.onload = () => {
        clearTimeout(timeout);
        document.body.removeChild(placeholder);
        resolve(img);
      };
    } else {
      // Fallback: load immediately if Intersection Observer not supported
      img.src = src;
    }
  });
};

/**
 * Preload multiple images with error tolerance
 */
export const preloadImages = async (images: WallpaperImage[]): Promise<WallpaperImage[]> => {
  const preloadPromises = images.map(async (image) => {
    try {
      await preloadImage(image.src);
      return { success: true, image };
    } catch (error) {
      console.warn(`Failed to preload image: ${image.src}`, error);
      return { success: false, image, error };
    }
  });
  
  const results = await Promise.all(preloadPromises);
  const successfulImages = results
    .filter(result => result.success)
    .map(result => result.image);
  
  const failedCount = results.length - successfulImages.length;
  
  if (failedCount > 0) {
    console.warn(`${failedCount} out of ${images.length} images failed to preload`);
  } else {
    console.log(`Successfully preloaded ${images.length} images`);
  }
  
  return successfulImages;
};

/**
 * Lazy load multiple images with priority system
 */
export const lazyLoadImages = async (
  images: WallpaperImage[], 
  options: {
    priority?: 'high' | 'normal' | 'low';
    batchSize?: number;
    delay?: number;
  } = {}
): Promise<WallpaperImage[]> => {
  const { priority = 'normal', batchSize = 3, delay = 100 } = options;
  
  // Adjust loading strategy based on priority
  const loadingDelay = priority === 'high' ? 0 : priority === 'normal' ? delay : delay * 2;
  const currentBatchSize = priority === 'high' ? batchSize * 2 : batchSize;
  
  const successfulImages: WallpaperImage[] = [];
  
  // Process images in batches to avoid overwhelming the browser
  for (let i = 0; i < images.length; i += currentBatchSize) {
    const batch = images.slice(i, i + currentBatchSize);
    
    const batchPromises = batch.map(async (image) => {
      try {
        await lazyLoadImage(image.src);
        return { success: true, image };
      } catch (error) {
        console.warn(`Failed to lazy load image: ${image.src}`, error);
        return { success: false, image, error };
      }
    });
    
    const batchResults = await Promise.all(batchPromises);
    const batchSuccessful = batchResults
      .filter(result => result.success)
      .map(result => result.image);
    
    successfulImages.push(...batchSuccessful);
    
    // Add delay between batches (except for high priority)
    if (loadingDelay > 0 && i + currentBatchSize < images.length) {
      await new Promise(resolve => setTimeout(resolve, loadingDelay));
    }
  }
  
  console.log(`Lazy loaded ${successfulImages.length} out of ${images.length} images (priority: ${priority})`);
  return successfulImages;
};

/**
 * Check if an image exists and can be loaded
 */
export const checkImageExists = async (src: string): Promise<boolean> => {
  try {
    await preloadImage(src);
    return true;
  } catch {
    return false;
  }
};

/**
 * Get a random image from the available images
 */
export const getRandomImage = (images: WallpaperImage[]): WallpaperImage | null => {
  if (images.length === 0) return null;
  
  const randomIndex = Math.floor(Math.random() * images.length);
  return images[randomIndex];
};

/**
 * Get the next image in sequence
 */
export const getNextImage = (images: WallpaperImage[], currentIndex: number): { image: WallpaperImage | null; nextIndex: number } => {
  if (images.length === 0) return { image: null, nextIndex: 0 };
  
  const nextIndex = (currentIndex + 1) % images.length;
  return {
    image: images[nextIndex],
    nextIndex
  };
};

/**
 * Validate category name
 */
export const isValidCategory = (category: string): boolean => {
  return WALLPAPER_CATEGORIES.some(cat => cat.name === category);
};

/**
 * Get display name for category
 */
export const getCategoryDisplayName = (category: string): string => {
  const categoryConfig = WALLPAPER_CATEGORIES.find(cat => cat.name === category);
  return categoryConfig?.displayName || category;
};

/**
 * Validate and filter working images from a list
 */
export const validateImages = async (images: WallpaperImage[]): Promise<WallpaperImage[]> => {
  if (images.length === 0) return [];
  
  const validationPromises = images.map(async (image) => {
    try {
      const exists = await checkImageExists(image.src);
      return exists ? image : null;
    } catch {
      return null;
    }
  });
  
  const results = await Promise.all(validationPromises);
  const validImages = results.filter((image): image is WallpaperImage => image !== null);
  
  if (validImages.length < images.length) {
    console.warn(`${images.length - validImages.length} images failed validation`);
  }
  
  return validImages;
};

/**
 * Get images with fallback handling for missing files
 */
export const getImagesWithFallback = async (selectedCategories: string[]): Promise<{
  images: WallpaperImage[];
  errors: string[];
}> => {
  const allImages: WallpaperImage[] = [];
  const errors: string[] = [];
  
  if (selectedCategories.length === 0) {
    return { images: [], errors: [] };
  }
  
  for (const category of selectedCategories) {
    try {
      const categoryImages = await getImagesForCategory(category);
      if (categoryImages.length > 0) {
        // Skip validation for now - just add all images from manifest
        allImages.push(...categoryImages);
        console.log(`Added ${categoryImages.length} images from category: ${category}`);
      } else {
        errors.push(`No images configured for category: ${category}`);
      }
    } catch (error) {
      errors.push(`Failed to load category ${category}: ${error}`);
    }
  }
  
  return { images: allImages, errors };
};

/**
 * Get statistics for category filtering
 */
export const getCategoryFilteringStats = async (selectedCategories: string[]): Promise<{
  totalCategories: number;
  selectedCategories: number;
  totalImages: number;
  categoriesWithImages: string[];
  categoriesWithoutImages: string[];
}> => {
  const categoriesWithImages: string[] = [];
  const categoriesWithoutImages: string[] = [];
  let totalImages = 0;

  for (const category of selectedCategories) {
    try {
      const images = await getImagesForCategory(category);
      if (images.length > 0) {
        categoriesWithImages.push(category);
        totalImages += images.length;
      } else {
        categoriesWithoutImages.push(category);
      }
    } catch {
      categoriesWithoutImages.push(category);
    }
  }

  return {
    totalCategories: WALLPAPER_CATEGORIES.length,
    selectedCategories: selectedCategories.length,
    totalImages,
    categoriesWithImages,
    categoriesWithoutImages
  };
};

/**
 * Update category image counts dynamically
 */
export const updateCategoryImageCounts = async (): Promise<CategoryConfig[]> => {
  const updatedCategories = [...WALLPAPER_CATEGORIES];
  
  for (const category of updatedCategories) {
    try {
      const images = await getImagesForCategory(category.name);
      category.imageCount = images.length;
    } catch (error) {
      console.warn(`Failed to count images for category ${category.name}:`, error);
      category.imageCount = 0;
    }
  }
  
  return updatedCategories;
};

/**
 * Get filtered categories with immediate effect
 * This function provides real-time filtering results for the UI
 */
export const getFilteredCategoriesWithEffect = async (selectedCategories: string[]): Promise<{
  filteredImages: WallpaperImage[];
  categoryStats: {
    [categoryName: string]: {
      selected: boolean;
      imageCount: number;
      hasImages: boolean;
    };
  };
  totalSelectedImages: number;
  hasAnyImages: boolean;
}> => {
  const { images: filteredImages } = await getImagesWithFallback(selectedCategories);
  const categoryStats: { [categoryName: string]: { selected: boolean; imageCount: number; hasImages: boolean } } = {};
  
  // Get stats for all categories
  for (const category of WALLPAPER_CATEGORIES) {
    const isSelected = selectedCategories.includes(category.name);
    const categoryImages = await getImagesForCategory(category.name);
    
    categoryStats[category.name] = {
      selected: isSelected,
      imageCount: categoryImages.length,
      hasImages: categoryImages.length > 0
    };
  }
  
  return {
    filteredImages,
    categoryStats,
    totalSelectedImages: filteredImages.length,
    hasAnyImages: filteredImages.length > 0
  };
};