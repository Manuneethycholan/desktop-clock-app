{"ast":null,"code":"import{useState,useEffect,useCallback}from'react';import{getImagesWithFallback,preloadImages}from'../utils/imageLoader';/**\n * Custom hook for managing wallpaper rotation\n */export const useWallpaperRotation=(categories,rotationInterval,wallpaperSize,enabled)=>{const[availableImages,setAvailableImages]=useState([]);const[currentImage,setCurrentImage]=useState(null);const[currentIndex,setCurrentIndex]=useState(0);const[isLoading,setIsLoading]=useState(true);const[error,setError]=useState(null);// Load images for selected categories\nconst loadImages=useCallback(async()=>{if(categories.length===0){setAvailableImages([]);setCurrentImage(null);setCurrentIndex(0);setIsLoading(false);setError(null);return;}try{setIsLoading(true);setError(null);const{images,errors}=await getImagesWithFallback(categories);if(errors.length>0){console.warn('Image loading errors:',errors);}if(images.length===0){const errorMessage=errors.length>0?\"No valid images found: \".concat(errors.join(', ')):'No images found for selected categories';console.warn(errorMessage);setError(errorMessage);setAvailableImages([]);setCurrentImage(null);setCurrentIndex(0);}else{setAvailableImages(images);// Start with a random image instead of the first one\nconst randomIndex=Math.floor(Math.random()*images.length);setCurrentImage(images[randomIndex]);setCurrentIndex(randomIndex);// Preload a few random images for smooth transitions with error handling\ntry{const randomImagesToPreload=[];for(let i=0;i<Math.min(3,images.length);i++){const preloadIndex=Math.floor(Math.random()*images.length);randomImagesToPreload.push(images[preloadIndex]);}const validImages=await preloadImages(randomImagesToPreload);if(validImages.length<randomImagesToPreload.length){console.warn('Some images failed to preload, but continuing with available images');}}catch(preloadError){console.warn('Image preloading failed, but continuing with basic loading:',preloadError);}}}catch(err){console.error('Error loading wallpaper images:',err);setError(\"Failed to load wallpaper images: \".concat(err instanceof Error?err.message:'Unknown error'));setAvailableImages([]);setCurrentImage(null);setCurrentIndex(0);}finally{setIsLoading(false);}},[categories]);// Move to next image with random selection\nconst nextImage=useCallback(()=>{if(availableImages.length===0)return;try{// Get random image instead of sequential\nconst randomIndex=Math.floor(Math.random()*availableImages.length);const randomImage=availableImages[randomIndex];setCurrentImage(randomImage);setCurrentIndex(randomIndex);// Preload a few random images with error handling\nconst imagesToPreload=[];for(let i=0;i<2;i++){const preloadIndex=Math.floor(Math.random()*availableImages.length);if(preloadIndex!==randomIndex){imagesToPreload.push(availableImages[preloadIndex]);}}// Preload in background without blocking UI\npreloadImages(imagesToPreload).catch(error=>{console.warn('Background image preloading failed:',error);});}catch(error){console.error('Error switching to next image:',error);// Don't update state if there's an error, keep current image\n}},[availableImages,currentIndex]);// Set up rotation interval\nuseEffect(()=>{if(!enabled||availableImages.length<=1)return;const interval=setInterval(nextImage,rotationInterval);return()=>clearInterval(interval);},[enabled,availableImages.length,rotationInterval,nextImage]);// Load images when categories change\nuseEffect(()=>{loadImages();},[loadImages]);// Get CSS scale value based on wallpaper size\nconst getScaleValue=useCallback(()=>{switch(wallpaperSize){case'enlarged':return 1.3;case'normal':default:return 1.0;}},[wallpaperSize]);return{currentImage,availableImages,currentIndex,isLoading,error,nextImage,scaleValue:getScaleValue(),hasImages:availableImages.length>0};};","map":{"version":3,"names":["useState","useEffect","useCallback","getImagesWithFallback","preloadImages","useWallpaperRotation","categories","rotationInterval","wallpaperSize","enabled","availableImages","setAvailableImages","currentImage","setCurrentImage","currentIndex","setCurrentIndex","isLoading","setIsLoading","error","setError","loadImages","length","images","errors","console","warn","errorMessage","concat","join","randomIndex","Math","floor","random","randomImagesToPreload","i","min","preloadIndex","push","validImages","preloadError","err","Error","message","nextImage","randomImage","imagesToPreload","catch","interval","setInterval","clearInterval","getScaleValue","scaleValue","hasImages"],"sources":["/Users/chmanune/Project/Github_wall_paper_project/desktop-clock-app/src/hooks/useWallpaperRotation.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport { WallpaperImage, WallpaperSize } from '../types';\nimport { getImagesWithFallback, preloadImages, getNextImage } from '../utils/imageLoader';\n\n/**\n * Custom hook for managing wallpaper rotation\n */\nexport const useWallpaperRotation = (\n  categories: string[],\n  rotationInterval: number,\n  wallpaperSize: WallpaperSize,\n  enabled: boolean\n) => {\n  const [availableImages, setAvailableImages] = useState<WallpaperImage[]>([]);\n  const [currentImage, setCurrentImage] = useState<WallpaperImage | null>(null);\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Load images for selected categories\n  const loadImages = useCallback(async () => {\n    if (categories.length === 0) {\n      setAvailableImages([]);\n      setCurrentImage(null);\n      setCurrentIndex(0);\n      setIsLoading(false);\n      setError(null);\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      const { images, errors } = await getImagesWithFallback(categories);\n      \n      if (errors.length > 0) {\n        console.warn('Image loading errors:', errors);\n      }\n      \n      if (images.length === 0) {\n        const errorMessage = errors.length > 0 \n          ? `No valid images found: ${errors.join(', ')}`\n          : 'No images found for selected categories';\n        console.warn(errorMessage);\n        setError(errorMessage);\n        setAvailableImages([]);\n        setCurrentImage(null);\n        setCurrentIndex(0);\n      } else {\n        setAvailableImages(images);\n        \n        // Start with a random image instead of the first one\n        const randomIndex = Math.floor(Math.random() * images.length);\n        setCurrentImage(images[randomIndex]);\n        setCurrentIndex(randomIndex);\n        \n        // Preload a few random images for smooth transitions with error handling\n        try {\n          const randomImagesToPreload = [];\n          for (let i = 0; i < Math.min(3, images.length); i++) {\n            const preloadIndex = Math.floor(Math.random() * images.length);\n            randomImagesToPreload.push(images[preloadIndex]);\n          }\n          const validImages = await preloadImages(randomImagesToPreload);\n          if (validImages.length < randomImagesToPreload.length) {\n            console.warn('Some images failed to preload, but continuing with available images');\n          }\n        } catch (preloadError) {\n          console.warn('Image preloading failed, but continuing with basic loading:', preloadError);\n        }\n      }\n    } catch (err) {\n      console.error('Error loading wallpaper images:', err);\n      setError(`Failed to load wallpaper images: ${err instanceof Error ? err.message : 'Unknown error'}`);\n      setAvailableImages([]);\n      setCurrentImage(null);\n      setCurrentIndex(0);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [categories]);\n\n  // Move to next image with random selection\n  const nextImage = useCallback(() => {\n    if (availableImages.length === 0) return;\n    \n    try {\n      // Get random image instead of sequential\n      const randomIndex = Math.floor(Math.random() * availableImages.length);\n      const randomImage = availableImages[randomIndex];\n      \n      setCurrentImage(randomImage);\n      setCurrentIndex(randomIndex);\n      \n      // Preload a few random images with error handling\n      const imagesToPreload = [];\n      for (let i = 0; i < 2; i++) {\n        const preloadIndex = Math.floor(Math.random() * availableImages.length);\n        if (preloadIndex !== randomIndex) {\n          imagesToPreload.push(availableImages[preloadIndex]);\n        }\n      }\n      \n      // Preload in background without blocking UI\n      preloadImages(imagesToPreload).catch(error => {\n        console.warn('Background image preloading failed:', error);\n      });\n    } catch (error) {\n      console.error('Error switching to next image:', error);\n      // Don't update state if there's an error, keep current image\n    }\n  }, [availableImages, currentIndex]);\n\n  // Set up rotation interval\n  useEffect(() => {\n    if (!enabled || availableImages.length <= 1) return;\n\n    const interval = setInterval(nextImage, rotationInterval);\n    return () => clearInterval(interval);\n  }, [enabled, availableImages.length, rotationInterval, nextImage]);\n\n  // Load images when categories change\n  useEffect(() => {\n    loadImages();\n  }, [loadImages]);\n\n  // Get CSS scale value based on wallpaper size\n  const getScaleValue = useCallback((): number => {\n    switch (wallpaperSize) {\n      case 'enlarged':\n        return 1.3;\n      case 'normal':\n      default:\n        return 1.0;\n    }\n  }, [wallpaperSize]);\n\n  return {\n    currentImage,\n    availableImages,\n    currentIndex,\n    isLoading,\n    error,\n    nextImage,\n    scaleValue: getScaleValue(),\n    hasImages: availableImages.length > 0,\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}