{"ast":null,"code":"import { WALLPAPER_CATEGORIES } from './constants';\n\n// Import the generated image manifest (will be created by build script)\nlet imageManifest = {};\n\n// Try to load the manifest, fallback to hardcoded list if not available\ntry {\n  // This will be generated by the build script\n  imageManifest = require('../data/imageManifest.json');\n} catch {\n  // Fallback to current known images\n  imageManifest = {\n    rajini: ['2a54a5f5b7a844923311411a2d68da3c.jpg', '9215ed34ce4c841ef307d148339f6515.jpg', 'bf424df0eca803526cee028a9ef419c8.jpg', 'c192692294a5f6a269794a1f7cc738cf.jpg', 'efc647edaadddc9b8d2084ec3a0d0436.jpg', 'Thalapathy Movie Rajinikanth.jpeg'],\n    kamal: ['6a6408be15cd1e70a5df0f9848b6a5af (1).jpg', '6a6408be15cd1e70a5df0f9848b6a5af.jpg', '8b707f8aaae421c1138c4ffb5f7628bb.jpg'],\n    nature: [],\n    cars: [],\n    bikes: [],\n    spiritual: [],\n    motivational: [],\n    international: [],\n    tech: []\n  };\n}\n\n/**\n * Utility functions for loading and managing wallpaper images\n */\n\n/**\n * Get all available images for specified categories (USER SELECTED CATEGORIES)\n * This is where the filtering happens based on user's category selection\n */\nexport const getImagesForCategories = async selectedCategories => {\n  const allImages = [];\n\n  // Only process the categories that the user has selected\n  for (const category of selectedCategories) {\n    try {\n      const categoryImages = await getImagesForCategory(category);\n      allImages.push(...categoryImages);\n    } catch (error) {\n      console.warn(`Failed to load images for category: ${category}`, error);\n    }\n  }\n  console.log(`Loaded ${allImages.length} images from selected categories:`, selectedCategories);\n  return allImages;\n};\n\n/**\n * Get all images for a specific category from the manifest\n */\nexport const getImagesForCategory = async category => {\n  const filenames = imageManifest[category] || [];\n  return filenames.map(filename => ({\n    src: `/wallpapers/${category}/${filename}`,\n    category,\n    filename\n  }));\n};\n\n/**\n * Preload an image to ensure smooth transitions\n */\nexport const preloadImage = src => {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve();\n    img.onerror = () => reject(new Error(`Failed to load image: ${src}`));\n    img.src = src;\n  });\n};\n\n/**\n * Preload multiple images\n */\nexport const preloadImages = async images => {\n  const preloadPromises = images.map(image => preloadImage(image.src));\n  try {\n    await Promise.all(preloadPromises);\n    console.log(`Successfully preloaded ${images.length} images`);\n  } catch (error) {\n    console.warn('Some images failed to preload:', error);\n  }\n};\n\n/**\n * Check if an image exists and can be loaded\n */\nexport const checkImageExists = async src => {\n  try {\n    await preloadImage(src);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Get a random image from the available images\n */\nexport const getRandomImage = images => {\n  if (images.length === 0) return null;\n  const randomIndex = Math.floor(Math.random() * images.length);\n  return images[randomIndex];\n};\n\n/**\n * Get the next image in sequence\n */\nexport const getNextImage = (images, currentIndex) => {\n  if (images.length === 0) return {\n    image: null,\n    nextIndex: 0\n  };\n  const nextIndex = (currentIndex + 1) % images.length;\n  return {\n    image: images[nextIndex],\n    nextIndex\n  };\n};\n\n/**\n * Validate category name\n */\nexport const isValidCategory = category => {\n  return WALLPAPER_CATEGORIES.some(cat => cat.name === category);\n};\n\n/**\n * Get display name for category\n */\nexport const getCategoryDisplayName = category => {\n  const categoryConfig = WALLPAPER_CATEGORIES.find(cat => cat.name === category);\n  return (categoryConfig === null || categoryConfig === void 0 ? void 0 : categoryConfig.displayName) || category;\n};","map":{"version":3,"names":["WALLPAPER_CATEGORIES","imageManifest","require","rajini","kamal","nature","cars","bikes","spiritual","motivational","international","tech","getImagesForCategories","selectedCategories","allImages","category","categoryImages","getImagesForCategory","push","error","console","warn","log","length","filenames","map","filename","src","preloadImage","Promise","resolve","reject","img","Image","onload","onerror","Error","preloadImages","images","preloadPromises","image","all","checkImageExists","getRandomImage","randomIndex","Math","floor","random","getNextImage","currentIndex","nextIndex","isValidCategory","some","cat","name","getCategoryDisplayName","categoryConfig","find","displayName"],"sources":["/Users/chmanune/Project/Github_wall_paper_project/desktop-clock-app/src/utils/imageLoader.ts"],"sourcesContent":["import { WallpaperImage } from '../types';\nimport { WALLPAPER_CATEGORIES } from './constants';\n\n// Import the generated image manifest (will be created by build script)\nlet imageManifest: Record<string, string[]> = {};\n\n// Try to load the manifest, fallback to hardcoded list if not available\ntry {\n  // This will be generated by the build script\n  imageManifest = require('../data/imageManifest.json');\n} catch {\n  // Fallback to current known images\n  imageManifest = {\n    rajini: [\n      '2a54a5f5b7a844923311411a2d68da3c.jpg',\n      '9215ed34ce4c841ef307d148339f6515.jpg',\n      'bf424df0eca803526cee028a9ef419c8.jpg',\n      'c192692294a5f6a269794a1f7cc738cf.jpg',\n      'efc647edaadddc9b8d2084ec3a0d0436.jpg',\n      'Thalapathy Movie Rajinikanth.jpeg'\n    ],\n    kamal: [\n      '6a6408be15cd1e70a5df0f9848b6a5af (1).jpg',\n      '6a6408be15cd1e70a5df0f9848b6a5af.jpg',\n      '8b707f8aaae421c1138c4ffb5f7628bb.jpg'\n    ],\n    nature: [],\n    cars: [],\n    bikes: [],\n    spiritual: [],\n    motivational: [],\n    international: [],\n    tech: []\n  };\n}\n\n/**\n * Utility functions for loading and managing wallpaper images\n */\n\n/**\n * Get all available images for specified categories (USER SELECTED CATEGORIES)\n * This is where the filtering happens based on user's category selection\n */\nexport const getImagesForCategories = async (selectedCategories: string[]): Promise<WallpaperImage[]> => {\n  const allImages: WallpaperImage[] = [];\n  \n  // Only process the categories that the user has selected\n  for (const category of selectedCategories) {\n    try {\n      const categoryImages = await getImagesForCategory(category);\n      allImages.push(...categoryImages);\n    } catch (error) {\n      console.warn(`Failed to load images for category: ${category}`, error);\n    }\n  }\n  \n  console.log(`Loaded ${allImages.length} images from selected categories:`, selectedCategories);\n  return allImages;\n};\n\n/**\n * Get all images for a specific category from the manifest\n */\nexport const getImagesForCategory = async (category: string): Promise<WallpaperImage[]> => {\n  const filenames = imageManifest[category] || [];\n  \n  return filenames.map(filename => ({\n    src: `/wallpapers/${category}/${filename}`,\n    category,\n    filename\n  }));\n};\n\n/**\n * Preload an image to ensure smooth transitions\n */\nexport const preloadImage = (src: string): Promise<void> => {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    \n    img.onload = () => resolve();\n    img.onerror = () => reject(new Error(`Failed to load image: ${src}`));\n    \n    img.src = src;\n  });\n};\n\n/**\n * Preload multiple images\n */\nexport const preloadImages = async (images: WallpaperImage[]): Promise<void> => {\n  const preloadPromises = images.map(image => preloadImage(image.src));\n  \n  try {\n    await Promise.all(preloadPromises);\n    console.log(`Successfully preloaded ${images.length} images`);\n  } catch (error) {\n    console.warn('Some images failed to preload:', error);\n  }\n};\n\n/**\n * Check if an image exists and can be loaded\n */\nexport const checkImageExists = async (src: string): Promise<boolean> => {\n  try {\n    await preloadImage(src);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Get a random image from the available images\n */\nexport const getRandomImage = (images: WallpaperImage[]): WallpaperImage | null => {\n  if (images.length === 0) return null;\n  \n  const randomIndex = Math.floor(Math.random() * images.length);\n  return images[randomIndex];\n};\n\n/**\n * Get the next image in sequence\n */\nexport const getNextImage = (images: WallpaperImage[], currentIndex: number): { image: WallpaperImage | null; nextIndex: number } => {\n  if (images.length === 0) return { image: null, nextIndex: 0 };\n  \n  const nextIndex = (currentIndex + 1) % images.length;\n  return {\n    image: images[nextIndex],\n    nextIndex\n  };\n};\n\n/**\n * Validate category name\n */\nexport const isValidCategory = (category: string): boolean => {\n  return WALLPAPER_CATEGORIES.some(cat => cat.name === category);\n};\n\n/**\n * Get display name for category\n */\nexport const getCategoryDisplayName = (category: string): string => {\n  const categoryConfig = WALLPAPER_CATEGORIES.find(cat => cat.name === category);\n  return categoryConfig?.displayName || category;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}