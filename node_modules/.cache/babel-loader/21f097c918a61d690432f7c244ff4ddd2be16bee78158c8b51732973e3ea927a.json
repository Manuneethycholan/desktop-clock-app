{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\nimport { getImagesWithFallback, preloadImages } from '../utils/imageLoader';\n\n/**\n * Custom hook for managing wallpaper rotation\n */\nexport const useWallpaperRotation = (categories, rotationInterval, wallpaperSize, enabled) => {\n  _s();\n  const [availableImages, setAvailableImages] = useState([]);\n  const [currentImage, setCurrentImage] = useState(null);\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // Load images for selected categories\n  const loadImages = useCallback(async () => {\n    if (categories.length === 0) {\n      setAvailableImages([]);\n      setCurrentImage(null);\n      setCurrentIndex(0);\n      setIsLoading(false);\n      setError(null);\n      return;\n    }\n    try {\n      setIsLoading(true);\n      setError(null);\n      const {\n        images,\n        errors\n      } = await getImagesWithFallback(categories);\n      if (errors.length > 0) {\n        console.warn('Image loading errors:', errors);\n      }\n      if (images.length === 0) {\n        const errorMessage = errors.length > 0 ? `No valid images found: ${errors.join(', ')}` : 'No images found for selected categories';\n        console.warn(errorMessage);\n        setError(errorMessage);\n        setAvailableImages([]);\n        setCurrentImage(null);\n        setCurrentIndex(0);\n      } else {\n        setAvailableImages(images);\n\n        // Start with a random image instead of the first one\n        const randomIndex = Math.floor(Math.random() * images.length);\n        setCurrentImage(images[randomIndex]);\n        setCurrentIndex(randomIndex);\n\n        // Preload a few random images for smooth transitions with error handling\n        try {\n          const randomImagesToPreload = [];\n          for (let i = 0; i < Math.min(3, images.length); i++) {\n            const preloadIndex = Math.floor(Math.random() * images.length);\n            randomImagesToPreload.push(images[preloadIndex]);\n          }\n          const validImages = await preloadImages(randomImagesToPreload);\n          if (validImages.length < randomImagesToPreload.length) {\n            console.warn('Some images failed to preload, but continuing with available images');\n          }\n        } catch (preloadError) {\n          console.warn('Image preloading failed, but continuing with basic loading:', preloadError);\n        }\n      }\n    } catch (err) {\n      console.error('Error loading wallpaper images:', err);\n      setError(`Failed to load wallpaper images: ${err instanceof Error ? err.message : 'Unknown error'}`);\n      setAvailableImages([]);\n      setCurrentImage(null);\n      setCurrentIndex(0);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [categories]);\n\n  // Move to next image with random selection\n  const nextImage = useCallback(() => {\n    if (availableImages.length === 0) return;\n    try {\n      // Get random image instead of sequential\n      const randomIndex = Math.floor(Math.random() * availableImages.length);\n      const randomImage = availableImages[randomIndex];\n      setCurrentImage(randomImage);\n      setCurrentIndex(randomIndex);\n\n      // Preload a few random images with error handling\n      const imagesToPreload = [];\n      for (let i = 0; i < 2; i++) {\n        const preloadIndex = Math.floor(Math.random() * availableImages.length);\n        if (preloadIndex !== randomIndex) {\n          imagesToPreload.push(availableImages[preloadIndex]);\n        }\n      }\n\n      // Preload in background without blocking UI\n      preloadImages(imagesToPreload).catch(error => {\n        console.warn('Background image preloading failed:', error);\n      });\n    } catch (error) {\n      console.error('Error switching to next image:', error);\n      // Don't update state if there's an error, keep current image\n    }\n  }, [availableImages, currentIndex]);\n\n  // Set up rotation interval\n  useEffect(() => {\n    if (!enabled || availableImages.length <= 1) return;\n    const interval = setInterval(nextImage, rotationInterval);\n    return () => clearInterval(interval);\n  }, [enabled, availableImages.length, rotationInterval, nextImage]);\n\n  // Load images when categories change\n  useEffect(() => {\n    loadImages();\n  }, [loadImages]);\n\n  // Get CSS scale value based on wallpaper size\n  const getScaleValue = useCallback(() => {\n    switch (wallpaperSize) {\n      case 'enlarged':\n        return 1.3;\n      case 'normal':\n      default:\n        return 1.0;\n    }\n  }, [wallpaperSize]);\n  return {\n    currentImage,\n    availableImages,\n    currentIndex,\n    isLoading,\n    error,\n    nextImage,\n    scaleValue: getScaleValue(),\n    hasImages: availableImages.length > 0\n  };\n};\n_s(useWallpaperRotation, \"BzYwEZm5+Hf1jPli+iVW5GoZKuU=\");","map":{"version":3,"names":["useState","useEffect","useCallback","getImagesWithFallback","preloadImages","useWallpaperRotation","categories","rotationInterval","wallpaperSize","enabled","_s","availableImages","setAvailableImages","currentImage","setCurrentImage","currentIndex","setCurrentIndex","isLoading","setIsLoading","error","setError","loadImages","length","images","errors","console","warn","errorMessage","join","randomIndex","Math","floor","random","randomImagesToPreload","i","min","preloadIndex","push","validImages","preloadError","err","Error","message","nextImage","randomImage","imagesToPreload","catch","interval","setInterval","clearInterval","getScaleValue","scaleValue","hasImages"],"sources":["/Users/chmanune/Project/Github_wall_paper_project/desktop-clock-app/src/hooks/useWallpaperRotation.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport { WallpaperImage, WallpaperSize } from '../types';\nimport { getImagesWithFallback, preloadImages, getNextImage } from '../utils/imageLoader';\n\n/**\n * Custom hook for managing wallpaper rotation\n */\nexport const useWallpaperRotation = (\n  categories: string[],\n  rotationInterval: number,\n  wallpaperSize: WallpaperSize,\n  enabled: boolean\n) => {\n  const [availableImages, setAvailableImages] = useState<WallpaperImage[]>([]);\n  const [currentImage, setCurrentImage] = useState<WallpaperImage | null>(null);\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Load images for selected categories\n  const loadImages = useCallback(async () => {\n    if (categories.length === 0) {\n      setAvailableImages([]);\n      setCurrentImage(null);\n      setCurrentIndex(0);\n      setIsLoading(false);\n      setError(null);\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      const { images, errors } = await getImagesWithFallback(categories);\n      \n      if (errors.length > 0) {\n        console.warn('Image loading errors:', errors);\n      }\n      \n      if (images.length === 0) {\n        const errorMessage = errors.length > 0 \n          ? `No valid images found: ${errors.join(', ')}`\n          : 'No images found for selected categories';\n        console.warn(errorMessage);\n        setError(errorMessage);\n        setAvailableImages([]);\n        setCurrentImage(null);\n        setCurrentIndex(0);\n      } else {\n        setAvailableImages(images);\n        \n        // Start with a random image instead of the first one\n        const randomIndex = Math.floor(Math.random() * images.length);\n        setCurrentImage(images[randomIndex]);\n        setCurrentIndex(randomIndex);\n        \n        // Preload a few random images for smooth transitions with error handling\n        try {\n          const randomImagesToPreload = [];\n          for (let i = 0; i < Math.min(3, images.length); i++) {\n            const preloadIndex = Math.floor(Math.random() * images.length);\n            randomImagesToPreload.push(images[preloadIndex]);\n          }\n          const validImages = await preloadImages(randomImagesToPreload);\n          if (validImages.length < randomImagesToPreload.length) {\n            console.warn('Some images failed to preload, but continuing with available images');\n          }\n        } catch (preloadError) {\n          console.warn('Image preloading failed, but continuing with basic loading:', preloadError);\n        }\n      }\n    } catch (err) {\n      console.error('Error loading wallpaper images:', err);\n      setError(`Failed to load wallpaper images: ${err instanceof Error ? err.message : 'Unknown error'}`);\n      setAvailableImages([]);\n      setCurrentImage(null);\n      setCurrentIndex(0);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [categories]);\n\n  // Move to next image with random selection\n  const nextImage = useCallback(() => {\n    if (availableImages.length === 0) return;\n    \n    try {\n      // Get random image instead of sequential\n      const randomIndex = Math.floor(Math.random() * availableImages.length);\n      const randomImage = availableImages[randomIndex];\n      \n      setCurrentImage(randomImage);\n      setCurrentIndex(randomIndex);\n      \n      // Preload a few random images with error handling\n      const imagesToPreload = [];\n      for (let i = 0; i < 2; i++) {\n        const preloadIndex = Math.floor(Math.random() * availableImages.length);\n        if (preloadIndex !== randomIndex) {\n          imagesToPreload.push(availableImages[preloadIndex]);\n        }\n      }\n      \n      // Preload in background without blocking UI\n      preloadImages(imagesToPreload).catch(error => {\n        console.warn('Background image preloading failed:', error);\n      });\n    } catch (error) {\n      console.error('Error switching to next image:', error);\n      // Don't update state if there's an error, keep current image\n    }\n  }, [availableImages, currentIndex]);\n\n  // Set up rotation interval\n  useEffect(() => {\n    if (!enabled || availableImages.length <= 1) return;\n\n    const interval = setInterval(nextImage, rotationInterval);\n    return () => clearInterval(interval);\n  }, [enabled, availableImages.length, rotationInterval, nextImage]);\n\n  // Load images when categories change\n  useEffect(() => {\n    loadImages();\n  }, [loadImages]);\n\n  // Get CSS scale value based on wallpaper size\n  const getScaleValue = useCallback((): number => {\n    switch (wallpaperSize) {\n      case 'enlarged':\n        return 1.3;\n      case 'normal':\n      default:\n        return 1.0;\n    }\n  }, [wallpaperSize]);\n\n  return {\n    currentImage,\n    availableImages,\n    currentIndex,\n    isLoading,\n    error,\n    nextImage,\n    scaleValue: getScaleValue(),\n    hasImages: availableImages.length > 0,\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}