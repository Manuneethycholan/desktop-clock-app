{"ast":null,"code":"import{WALLPAPER_CATEGORIES}from'./constants';// Import the generated image manifest (will be created by build script)\nlet imageManifest={};// Try to load the manifest, fallback to hardcoded list if not available\ntry{// This will be generated by the build script\nimageManifest=require('../data/imageManifest.json');}catch(_unused){// Fallback to current known images\nimageManifest={rajini:['2a54a5f5b7a844923311411a2d68da3c.jpg','9215ed34ce4c841ef307d148339f6515.jpg','bf424df0eca803526cee028a9ef419c8.jpg','c192692294a5f6a269794a1f7cc738cf.jpg','efc647edaadddc9b8d2084ec3a0d0436.jpg','Thalapathy Movie Rajinikanth.jpeg'],kamal:['6a6408be15cd1e70a5df0f9848b6a5af (1).jpg','6a6408be15cd1e70a5df0f9848b6a5af.jpg','8b707f8aaae421c1138c4ffb5f7628bb.jpg'],nature:[],cars:[],bikes:[],spiritual:[],motivational:[],international:[],tech:[]};}/**\n * Utility functions for loading and managing wallpaper images\n *//**\n * Get all available images for specified categories (USER SELECTED CATEGORIES)\n * This is where the filtering happens based on user's category selection\n */export const getImagesForCategories=async selectedCategories=>{const allImages=[];// Only process the categories that the user has selected\nfor(const category of selectedCategories){try{const categoryImages=await getImagesForCategory(category);allImages.push(...categoryImages);}catch(error){console.warn(\"Failed to load images for category: \".concat(category),error);}}console.log(\"Loaded \".concat(allImages.length,\" images from selected categories:\"),selectedCategories);return allImages;};/**\n * Get all images for a specific category from the manifest\n */export const getImagesForCategory=async category=>{const filenames=imageManifest[category]||[];return filenames.map(filename=>({src:\"/wallpapers/\".concat(category,\"/\").concat(filename),category,filename}));};/**\n * Preload an image to ensure smooth transitions\n */export const preloadImage=src=>{return new Promise((resolve,reject)=>{const img=new Image();img.onload=()=>resolve();img.onerror=()=>reject(new Error(\"Failed to load image: \".concat(src)));img.src=src;});};/**\n * Preload multiple images\n */export const preloadImages=async images=>{const preloadPromises=images.map(image=>preloadImage(image.src));try{await Promise.all(preloadPromises);console.log(\"Successfully preloaded \".concat(images.length,\" images\"));}catch(error){console.warn('Some images failed to preload:',error);}};/**\n * Check if an image exists and can be loaded\n */export const checkImageExists=async src=>{try{await preloadImage(src);return true;}catch(_unused2){return false;}};/**\n * Get a random image from the available images\n */export const getRandomImage=images=>{if(images.length===0)return null;const randomIndex=Math.floor(Math.random()*images.length);return images[randomIndex];};/**\n * Get the next image in sequence\n */export const getNextImage=(images,currentIndex)=>{if(images.length===0)return{image:null,nextIndex:0};const nextIndex=(currentIndex+1)%images.length;return{image:images[nextIndex],nextIndex};};/**\n * Validate category name\n */export const isValidCategory=category=>{return WALLPAPER_CATEGORIES.some(cat=>cat.name===category);};/**\n * Get display name for category\n */export const getCategoryDisplayName=category=>{const categoryConfig=WALLPAPER_CATEGORIES.find(cat=>cat.name===category);return(categoryConfig===null||categoryConfig===void 0?void 0:categoryConfig.displayName)||category;};","map":{"version":3,"names":["WALLPAPER_CATEGORIES","imageManifest","require","_unused","rajini","kamal","nature","cars","bikes","spiritual","motivational","international","tech","getImagesForCategories","selectedCategories","allImages","category","categoryImages","getImagesForCategory","push","error","console","warn","concat","log","length","filenames","map","filename","src","preloadImage","Promise","resolve","reject","img","Image","onload","onerror","Error","preloadImages","images","preloadPromises","image","all","checkImageExists","_unused2","getRandomImage","randomIndex","Math","floor","random","getNextImage","currentIndex","nextIndex","isValidCategory","some","cat","name","getCategoryDisplayName","categoryConfig","find","displayName"],"sources":["/Users/chmanune/Project/Github_wall_paper_project/desktop-clock-app/src/utils/imageLoader.ts"],"sourcesContent":["import { WallpaperImage } from '../types';\nimport { WALLPAPER_CATEGORIES } from './constants';\n\n// Import the generated image manifest (will be created by build script)\nlet imageManifest: Record<string, string[]> = {};\n\n// Try to load the manifest, fallback to hardcoded list if not available\ntry {\n  // This will be generated by the build script\n  imageManifest = require('../data/imageManifest.json');\n} catch {\n  // Fallback to current known images\n  imageManifest = {\n    rajini: [\n      '2a54a5f5b7a844923311411a2d68da3c.jpg',\n      '9215ed34ce4c841ef307d148339f6515.jpg',\n      'bf424df0eca803526cee028a9ef419c8.jpg',\n      'c192692294a5f6a269794a1f7cc738cf.jpg',\n      'efc647edaadddc9b8d2084ec3a0d0436.jpg',\n      'Thalapathy Movie Rajinikanth.jpeg'\n    ],\n    kamal: [\n      '6a6408be15cd1e70a5df0f9848b6a5af (1).jpg',\n      '6a6408be15cd1e70a5df0f9848b6a5af.jpg',\n      '8b707f8aaae421c1138c4ffb5f7628bb.jpg'\n    ],\n    nature: [],\n    cars: [],\n    bikes: [],\n    spiritual: [],\n    motivational: [],\n    international: [],\n    tech: []\n  };\n}\n\n/**\n * Utility functions for loading and managing wallpaper images\n */\n\n/**\n * Get all available images for specified categories (USER SELECTED CATEGORIES)\n * This is where the filtering happens based on user's category selection\n */\nexport const getImagesForCategories = async (selectedCategories: string[]): Promise<WallpaperImage[]> => {\n  const allImages: WallpaperImage[] = [];\n  \n  // Only process the categories that the user has selected\n  for (const category of selectedCategories) {\n    try {\n      const categoryImages = await getImagesForCategory(category);\n      allImages.push(...categoryImages);\n    } catch (error) {\n      console.warn(`Failed to load images for category: ${category}`, error);\n    }\n  }\n  \n  console.log(`Loaded ${allImages.length} images from selected categories:`, selectedCategories);\n  return allImages;\n};\n\n/**\n * Get all images for a specific category from the manifest\n */\nexport const getImagesForCategory = async (category: string): Promise<WallpaperImage[]> => {\n  const filenames = imageManifest[category] || [];\n  \n  return filenames.map(filename => ({\n    src: `/wallpapers/${category}/${filename}`,\n    category,\n    filename\n  }));\n};\n\n/**\n * Preload an image to ensure smooth transitions\n */\nexport const preloadImage = (src: string): Promise<void> => {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    \n    img.onload = () => resolve();\n    img.onerror = () => reject(new Error(`Failed to load image: ${src}`));\n    \n    img.src = src;\n  });\n};\n\n/**\n * Preload multiple images\n */\nexport const preloadImages = async (images: WallpaperImage[]): Promise<void> => {\n  const preloadPromises = images.map(image => preloadImage(image.src));\n  \n  try {\n    await Promise.all(preloadPromises);\n    console.log(`Successfully preloaded ${images.length} images`);\n  } catch (error) {\n    console.warn('Some images failed to preload:', error);\n  }\n};\n\n/**\n * Check if an image exists and can be loaded\n */\nexport const checkImageExists = async (src: string): Promise<boolean> => {\n  try {\n    await preloadImage(src);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Get a random image from the available images\n */\nexport const getRandomImage = (images: WallpaperImage[]): WallpaperImage | null => {\n  if (images.length === 0) return null;\n  \n  const randomIndex = Math.floor(Math.random() * images.length);\n  return images[randomIndex];\n};\n\n/**\n * Get the next image in sequence\n */\nexport const getNextImage = (images: WallpaperImage[], currentIndex: number): { image: WallpaperImage | null; nextIndex: number } => {\n  if (images.length === 0) return { image: null, nextIndex: 0 };\n  \n  const nextIndex = (currentIndex + 1) % images.length;\n  return {\n    image: images[nextIndex],\n    nextIndex\n  };\n};\n\n/**\n * Validate category name\n */\nexport const isValidCategory = (category: string): boolean => {\n  return WALLPAPER_CATEGORIES.some(cat => cat.name === category);\n};\n\n/**\n * Get display name for category\n */\nexport const getCategoryDisplayName = (category: string): string => {\n  const categoryConfig = WALLPAPER_CATEGORIES.find(cat => cat.name === category);\n  return categoryConfig?.displayName || category;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}