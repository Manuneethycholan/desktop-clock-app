{"ast":null,"code":"import { WALLPAPER_CATEGORIES } from './constants';\n\n// Import the generated image manifest (will be created by build script)\nlet imageManifest = {};\n\n// Try to load the manifest, fallback to hardcoded list if not available\ntry {\n  // This will be generated by the build script\n  imageManifest = require('../data/imageManifest.json');\n} catch {\n  // Fallback to current known images\n  imageManifest = {\n    rajini: ['2a54a5f5b7a844923311411a2d68da3c.jpg', '9215ed34ce4c841ef307d148339f6515.jpg', 'bf424df0eca803526cee028a9ef419c8.jpg', 'c192692294a5f6a269794a1f7cc738cf.jpg', 'efc647edaadddc9b8d2084ec3a0d0436.jpg', 'Thalapathy Movie Rajinikanth.jpeg'],\n    kamal: ['6a6408be15cd1e70a5df0f9848b6a5af (1).jpg', '6a6408be15cd1e70a5df0f9848b6a5af.jpg', '8b707f8aaae421c1138c4ffb5f7628bb.jpg'],\n    common_mass: ['618084c21a00942335d5ca3dac51ed17.jpg'],\n    anime: [],\n    nature: [],\n    cars: [],\n    bikes: [],\n    spiritual: [],\n    motivational: [],\n    tech: []\n  };\n}\n\n/**\n * Utility functions for loading and managing wallpaper images\n */\n\n/**\n * Get all available images for specified categories (USER SELECTED CATEGORIES)\n * This is where the filtering happens based on user's category selection\n */\nexport const getImagesForCategories = async selectedCategories => {\n  // Handle edge case: no categories selected\n  if (selectedCategories.length === 0) {\n    console.log('No categories selected - returning empty array for black background');\n    return [];\n  }\n  const allImages = [];\n  const failedCategories = [];\n\n  // Only process the categories that the user has selected\n  for (const category of selectedCategories) {\n    // Validate category name\n    if (!isValidCategory(category)) {\n      console.warn(`Invalid category name: ${category}`);\n      failedCategories.push(category);\n      continue;\n    }\n    try {\n      const categoryImages = await getImagesForCategory(category);\n      if (categoryImages.length > 0) {\n        allImages.push(...categoryImages);\n      } else {\n        console.warn(`No images found for category: ${category}`);\n        failedCategories.push(category);\n      }\n    } catch (error) {\n      console.warn(`Failed to load images for category: ${category}`, error);\n      failedCategories.push(category);\n    }\n  }\n\n  // Log results for debugging\n  const successfulCategories = selectedCategories.filter(cat => !failedCategories.includes(cat));\n  console.log(`Category filtering results:`, {\n    selectedCategories,\n    successfulCategories,\n    failedCategories,\n    totalImages: allImages.length\n  });\n  return allImages;\n};\n\n/**\n * Get all images for a specific category from the manifest\n */\nexport const getImagesForCategory = async category => {\n  const filenames = imageManifest[category] || [];\n  return filenames.map(filename => ({\n    src: `/wallpapers/${category}/${filename}`,\n    category,\n    filename\n  }));\n};\n\n/**\n * Preload an image to ensure smooth transitions\n */\nexport const preloadImage = src => {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n\n    // Set timeout to prevent hanging on slow/broken images\n    const timeout = setTimeout(() => {\n      reject(new Error(`Image load timeout: ${src}`));\n    }, 10000); // 10 second timeout\n\n    img.onload = () => {\n      clearTimeout(timeout);\n      resolve();\n    };\n    img.onerror = () => {\n      clearTimeout(timeout);\n      reject(new Error(`Failed to load image: ${src}`));\n    };\n    img.src = src;\n  });\n};\n\n/**\n * Preload multiple images with error tolerance\n */\nexport const preloadImages = async images => {\n  const preloadPromises = images.map(async image => {\n    try {\n      await preloadImage(image.src);\n      return {\n        success: true,\n        image\n      };\n    } catch (error) {\n      console.warn(`Failed to preload image: ${image.src}`, error);\n      return {\n        success: false,\n        image,\n        error\n      };\n    }\n  });\n  const results = await Promise.all(preloadPromises);\n  const successfulImages = results.filter(result => result.success).map(result => result.image);\n  const failedCount = results.length - successfulImages.length;\n  if (failedCount > 0) {\n    console.warn(`${failedCount} out of ${images.length} images failed to preload`);\n  } else {\n    console.log(`Successfully preloaded ${images.length} images`);\n  }\n  return successfulImages;\n};\n\n/**\n * Check if an image exists and can be loaded\n */\nexport const checkImageExists = async src => {\n  try {\n    await preloadImage(src);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Get a random image from the available images\n */\nexport const getRandomImage = images => {\n  if (images.length === 0) return null;\n  const randomIndex = Math.floor(Math.random() * images.length);\n  return images[randomIndex];\n};\n\n/**\n * Get the next image in sequence\n */\nexport const getNextImage = (images, currentIndex) => {\n  if (images.length === 0) return {\n    image: null,\n    nextIndex: 0\n  };\n  const nextIndex = (currentIndex + 1) % images.length;\n  return {\n    image: images[nextIndex],\n    nextIndex\n  };\n};\n\n/**\n * Validate category name\n */\nexport const isValidCategory = category => {\n  return WALLPAPER_CATEGORIES.some(cat => cat.name === category);\n};\n\n/**\n * Get display name for category\n */\nexport const getCategoryDisplayName = category => {\n  const categoryConfig = WALLPAPER_CATEGORIES.find(cat => cat.name === category);\n  return (categoryConfig === null || categoryConfig === void 0 ? void 0 : categoryConfig.displayName) || category;\n};\n\n/**\n * Validate and filter working images from a list\n */\nexport const validateImages = async images => {\n  if (images.length === 0) return [];\n  const validationPromises = images.map(async image => {\n    try {\n      const exists = await checkImageExists(image.src);\n      return exists ? image : null;\n    } catch {\n      return null;\n    }\n  });\n  const results = await Promise.all(validationPromises);\n  const validImages = results.filter(image => image !== null);\n  if (validImages.length < images.length) {\n    console.warn(`${images.length - validImages.length} images failed validation`);\n  }\n  return validImages;\n};\n\n/**\n * Get images with fallback handling for missing files\n */\nexport const getImagesWithFallback = async selectedCategories => {\n  const allImages = [];\n  const errors = [];\n  if (selectedCategories.length === 0) {\n    return {\n      images: [],\n      errors: []\n    };\n  }\n  for (const category of selectedCategories) {\n    try {\n      const categoryImages = await getImagesForCategory(category);\n      if (categoryImages.length > 0) {\n        // Validate images exist before adding them\n        const validImages = await validateImages(categoryImages);\n        if (validImages.length > 0) {\n          allImages.push(...validImages);\n        } else {\n          errors.push(`No valid images found in category: ${category}`);\n        }\n      } else {\n        errors.push(`No images configured for category: ${category}`);\n      }\n    } catch (error) {\n      errors.push(`Failed to load category ${category}: ${error}`);\n    }\n  }\n  return {\n    images: allImages,\n    errors\n  };\n};\n\n/**\n * Get statistics for category filtering\n */\nexport const getCategoryFilteringStats = async selectedCategories => {\n  const categoriesWithImages = [];\n  const categoriesWithoutImages = [];\n  let totalImages = 0;\n  for (const category of selectedCategories) {\n    try {\n      const images = await getImagesForCategory(category);\n      if (images.length > 0) {\n        categoriesWithImages.push(category);\n        totalImages += images.length;\n      } else {\n        categoriesWithoutImages.push(category);\n      }\n    } catch {\n      categoriesWithoutImages.push(category);\n    }\n  }\n  return {\n    totalCategories: WALLPAPER_CATEGORIES.length,\n    selectedCategories: selectedCategories.length,\n    totalImages,\n    categoriesWithImages,\n    categoriesWithoutImages\n  };\n};","map":{"version":3,"names":["WALLPAPER_CATEGORIES","imageManifest","require","rajini","kamal","common_mass","anime","nature","cars","bikes","spiritual","motivational","tech","getImagesForCategories","selectedCategories","length","console","log","allImages","failedCategories","category","isValidCategory","warn","push","categoryImages","getImagesForCategory","error","successfulCategories","filter","cat","includes","totalImages","filenames","map","filename","src","preloadImage","Promise","resolve","reject","img","Image","timeout","setTimeout","Error","onload","clearTimeout","onerror","preloadImages","images","preloadPromises","image","success","results","all","successfulImages","result","failedCount","checkImageExists","getRandomImage","randomIndex","Math","floor","random","getNextImage","currentIndex","nextIndex","some","name","getCategoryDisplayName","categoryConfig","find","displayName","validateImages","validationPromises","exists","validImages","getImagesWithFallback","errors","getCategoryFilteringStats","categoriesWithImages","categoriesWithoutImages","totalCategories"],"sources":["/Users/chmanune/Project/Github_wall_paper_project/desktop-clock-app/src/utils/imageLoader.ts"],"sourcesContent":["import { WallpaperImage } from '../types';\nimport { WALLPAPER_CATEGORIES } from './constants';\n\n// Import the generated image manifest (will be created by build script)\nlet imageManifest: Record<string, string[]> = {};\n\n// Try to load the manifest, fallback to hardcoded list if not available\ntry {\n  // This will be generated by the build script\n  imageManifest = require('../data/imageManifest.json');\n} catch {\n  // Fallback to current known images\n  imageManifest = {\n    rajini: [\n      '2a54a5f5b7a844923311411a2d68da3c.jpg',\n      '9215ed34ce4c841ef307d148339f6515.jpg',\n      'bf424df0eca803526cee028a9ef419c8.jpg',\n      'c192692294a5f6a269794a1f7cc738cf.jpg',\n      'efc647edaadddc9b8d2084ec3a0d0436.jpg',\n      'Thalapathy Movie Rajinikanth.jpeg'\n    ],\n    kamal: [\n      '6a6408be15cd1e70a5df0f9848b6a5af (1).jpg',\n      '6a6408be15cd1e70a5df0f9848b6a5af.jpg',\n      '8b707f8aaae421c1138c4ffb5f7628bb.jpg'\n    ],\n    common_mass: [\n      '618084c21a00942335d5ca3dac51ed17.jpg'\n    ],\n    anime: [],\n    nature: [],\n    cars: [],\n    bikes: [],\n    spiritual: [],\n    motivational: [],\n    tech: []\n  };\n}\n\n/**\n * Utility functions for loading and managing wallpaper images\n */\n\n/**\n * Get all available images for specified categories (USER SELECTED CATEGORIES)\n * This is where the filtering happens based on user's category selection\n */\nexport const getImagesForCategories = async (selectedCategories: string[]): Promise<WallpaperImage[]> => {\n  // Handle edge case: no categories selected\n  if (selectedCategories.length === 0) {\n    console.log('No categories selected - returning empty array for black background');\n    return [];\n  }\n\n  const allImages: WallpaperImage[] = [];\n  const failedCategories: string[] = [];\n  \n  // Only process the categories that the user has selected\n  for (const category of selectedCategories) {\n    // Validate category name\n    if (!isValidCategory(category)) {\n      console.warn(`Invalid category name: ${category}`);\n      failedCategories.push(category);\n      continue;\n    }\n\n    try {\n      const categoryImages = await getImagesForCategory(category);\n      if (categoryImages.length > 0) {\n        allImages.push(...categoryImages);\n      } else {\n        console.warn(`No images found for category: ${category}`);\n        failedCategories.push(category);\n      }\n    } catch (error) {\n      console.warn(`Failed to load images for category: ${category}`, error);\n      failedCategories.push(category);\n    }\n  }\n  \n  // Log results for debugging\n  const successfulCategories = selectedCategories.filter(cat => !failedCategories.includes(cat));\n  console.log(`Category filtering results:`, {\n    selectedCategories,\n    successfulCategories,\n    failedCategories,\n    totalImages: allImages.length\n  });\n  \n  return allImages;\n};\n\n/**\n * Get all images for a specific category from the manifest\n */\nexport const getImagesForCategory = async (category: string): Promise<WallpaperImage[]> => {\n  const filenames = imageManifest[category] || [];\n  \n  return filenames.map(filename => ({\n    src: `/wallpapers/${category}/${filename}`,\n    category,\n    filename\n  }));\n};\n\n/**\n * Preload an image to ensure smooth transitions\n */\nexport const preloadImage = (src: string): Promise<void> => {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    \n    // Set timeout to prevent hanging on slow/broken images\n    const timeout = setTimeout(() => {\n      reject(new Error(`Image load timeout: ${src}`));\n    }, 10000); // 10 second timeout\n    \n    img.onload = () => {\n      clearTimeout(timeout);\n      resolve();\n    };\n    \n    img.onerror = () => {\n      clearTimeout(timeout);\n      reject(new Error(`Failed to load image: ${src}`));\n    };\n    \n    img.src = src;\n  });\n};\n\n/**\n * Preload multiple images with error tolerance\n */\nexport const preloadImages = async (images: WallpaperImage[]): Promise<WallpaperImage[]> => {\n  const preloadPromises = images.map(async (image) => {\n    try {\n      await preloadImage(image.src);\n      return { success: true, image };\n    } catch (error) {\n      console.warn(`Failed to preload image: ${image.src}`, error);\n      return { success: false, image, error };\n    }\n  });\n  \n  const results = await Promise.all(preloadPromises);\n  const successfulImages = results\n    .filter(result => result.success)\n    .map(result => result.image);\n  \n  const failedCount = results.length - successfulImages.length;\n  \n  if (failedCount > 0) {\n    console.warn(`${failedCount} out of ${images.length} images failed to preload`);\n  } else {\n    console.log(`Successfully preloaded ${images.length} images`);\n  }\n  \n  return successfulImages;\n};\n\n/**\n * Check if an image exists and can be loaded\n */\nexport const checkImageExists = async (src: string): Promise<boolean> => {\n  try {\n    await preloadImage(src);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Get a random image from the available images\n */\nexport const getRandomImage = (images: WallpaperImage[]): WallpaperImage | null => {\n  if (images.length === 0) return null;\n  \n  const randomIndex = Math.floor(Math.random() * images.length);\n  return images[randomIndex];\n};\n\n/**\n * Get the next image in sequence\n */\nexport const getNextImage = (images: WallpaperImage[], currentIndex: number): { image: WallpaperImage | null; nextIndex: number } => {\n  if (images.length === 0) return { image: null, nextIndex: 0 };\n  \n  const nextIndex = (currentIndex + 1) % images.length;\n  return {\n    image: images[nextIndex],\n    nextIndex\n  };\n};\n\n/**\n * Validate category name\n */\nexport const isValidCategory = (category: string): boolean => {\n  return WALLPAPER_CATEGORIES.some(cat => cat.name === category);\n};\n\n/**\n * Get display name for category\n */\nexport const getCategoryDisplayName = (category: string): string => {\n  const categoryConfig = WALLPAPER_CATEGORIES.find(cat => cat.name === category);\n  return categoryConfig?.displayName || category;\n};\n\n/**\n * Validate and filter working images from a list\n */\nexport const validateImages = async (images: WallpaperImage[]): Promise<WallpaperImage[]> => {\n  if (images.length === 0) return [];\n  \n  const validationPromises = images.map(async (image) => {\n    try {\n      const exists = await checkImageExists(image.src);\n      return exists ? image : null;\n    } catch {\n      return null;\n    }\n  });\n  \n  const results = await Promise.all(validationPromises);\n  const validImages = results.filter((image): image is WallpaperImage => image !== null);\n  \n  if (validImages.length < images.length) {\n    console.warn(`${images.length - validImages.length} images failed validation`);\n  }\n  \n  return validImages;\n};\n\n/**\n * Get images with fallback handling for missing files\n */\nexport const getImagesWithFallback = async (selectedCategories: string[]): Promise<{\n  images: WallpaperImage[];\n  errors: string[];\n}> => {\n  const allImages: WallpaperImage[] = [];\n  const errors: string[] = [];\n  \n  if (selectedCategories.length === 0) {\n    return { images: [], errors: [] };\n  }\n  \n  for (const category of selectedCategories) {\n    try {\n      const categoryImages = await getImagesForCategory(category);\n      if (categoryImages.length > 0) {\n        // Validate images exist before adding them\n        const validImages = await validateImages(categoryImages);\n        if (validImages.length > 0) {\n          allImages.push(...validImages);\n        } else {\n          errors.push(`No valid images found in category: ${category}`);\n        }\n      } else {\n        errors.push(`No images configured for category: ${category}`);\n      }\n    } catch (error) {\n      errors.push(`Failed to load category ${category}: ${error}`);\n    }\n  }\n  \n  return { images: allImages, errors };\n};\n\n/**\n * Get statistics for category filtering\n */\nexport const getCategoryFilteringStats = async (selectedCategories: string[]): Promise<{\n  totalCategories: number;\n  selectedCategories: number;\n  totalImages: number;\n  categoriesWithImages: string[];\n  categoriesWithoutImages: string[];\n}> => {\n  const categoriesWithImages: string[] = [];\n  const categoriesWithoutImages: string[] = [];\n  let totalImages = 0;\n\n  for (const category of selectedCategories) {\n    try {\n      const images = await getImagesForCategory(category);\n      if (images.length > 0) {\n        categoriesWithImages.push(category);\n        totalImages += images.length;\n      } else {\n        categoriesWithoutImages.push(category);\n      }\n    } catch {\n      categoriesWithoutImages.push(category);\n    }\n  }\n\n  return {\n    totalCategories: WALLPAPER_CATEGORIES.length,\n    selectedCategories: selectedCategories.length,\n    totalImages,\n    categoriesWithImages,\n    categoriesWithoutImages\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}